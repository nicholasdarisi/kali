"""
Weeping CAN Attack Simulator con analisi bit-level e reinforcement learning
"""

import threading
import time
import random
from collections import defaultdict
import numpy as np
from sklearn.ensemble import RandomForestClassifier
from sklearn.multioutput import MultiOutputClassifier
import can
from enum import Enum, auto
from typing import List, Optional, Tuple
from dataclasses import dataclass

# --- Bit Value ---
class BitValue(Enum):
    DOMINANT = 0
    RECESSIVE = 1

    @staticmethod
    def from_int(v: int) -> "BitValue":
        return BitValue.DOMINANT if v == 0 else BitValue.RECESSIVE


# --- Node State ---
class NodeState(Enum):
    ERROR_ACTIVE = auto()
    ERROR_PASSIVE = auto()
    BUS_OFF = auto()


# --- Fields (bit-level) ---
class Field(Enum):
    SOF = auto()
    ID = auto()
    RTR = auto()
    IDE = auto()
    R0 = auto()
    DLC = auto()
    DATA = auto()
    CRC = auto()
    CRC_DELIM = auto()
    ACK = auto()
    ACK_DELIM = auto()
    EOF = auto()


@dataclass
class CANBit:
    field: Field
    value: BitValue


@dataclass
class CANFrameBits:
    sof: CANBit
    arbitration_id: List[CANBit]
    rtr: CANBit
    ide: CANBit
    r0: CANBit
    dlc: List[CANBit]
    data: List[CANBit]
    crc: List[CANBit]
    crc_delim: CANBit
    ack: CANBit
    ack_delim: CANBit
    eof: List[CANBit]

    def to_stream(self) -> List[CANBit]:
        stream = []
        stream.append(self.sof)
        stream.extend(self.arbitration_id)
        stream.append(self.rtr)
        stream.append(self.ide)
        stream.append(self.r0)
        stream.extend(self.dlc)
        stream.extend(self.data)
        stream.extend(self.crc)
        stream.append(self.crc_delim)
        stream.append(self.ack)
        stream.append(self.ack_delim)
        stream.extend(self.eof)
        return stream


# --- Helpers ---
def int_to_bits(val: int, width: int) -> List[BitValue]:
    return [BitValue.from_int((val >> (width - 1 - i)) & 1) for i in range(width)]


def bytes_to_bits(data: bytes) -> List[BitValue]:
    bits = []
    for b in data:
        bits.extend(int_to_bits(b, 8))
    return bits


# --- Master (bus arbitrage + error simulation) ---
class CANBusMaster:
    def __init__(self, use_vcan=True):
        self.ecus = {}
        self.pending = []  # list of (timestamp, ecu, arb_id, data, r0)
        self.lock = threading.Lock()

        self.running = False
        self.thread = None

        self.use_vcan = use_vcan
        self.bus = None
        if self.use_vcan:
            try:
                self.bus = can.interface.Bus(channel='vcan0', interface='socketcan')
                print("[MASTER] Connected to vcan0")
            except Exception as e:
                print(f"[MASTER] Error connecting vcan0: {e}")
                self.bus = None

    def register_ecu(self, ecu):
        self.ecus[getattr(ecu, "slave_id", id(ecu))] = ecu

    def start(self):
        self.running = True
        self.thread = threading.Thread(target=self._run, daemon=True)
        self.thread.start()

    def stop(self):
        self.running = False
        if self.bus:
            try:
                self.bus.shutdown()
            except Exception:
                pass

    def submit_transmission(self, ecu, data: bytes, arb_id: int, r0: BitValue = BitValue.RECESSIVE):
        with self.lock:
            self.pending.append((time.time(), ecu, arb_id, data, r0))

    def _send_on_vcan(self, arb_id: int, data: bytes):
        if not self.use_vcan or self.bus is None:
            return
        try:
            msg = can.Message(arbitration_id=arb_id, data=data, is_extended_id=False)
            self.bus.send(msg)
        except Exception as e:
            print(f"[MASTER] vcan send error: {e}")

    def _send_error_flag(self, ecu, active=True):
        if active:
            print(f"[MASTER] >>> ERROR FLAG ACTIVE generated by {getattr(ecu, 'name', 'ECU')} (dominant)")
        else:
            print(f"[MASTER] >>> ERROR FLAG PASSIVE generated by {getattr(ecu, 'name', 'ECU')} (recessive)")
        # NOTE: SocketCAN non supporta error frames reali. Qui solo logging.

    def _build_frame_bits(self, arb_id: int, data: bytes, r0: BitValue) -> CANFrameBits:
        sof = CANBit(Field.SOF, BitValue.DOMINANT)
        arbitration_id = [CANBit(Field.ID, b) for b in int_to_bits(arb_id, 11)]
        rtr = CANBit(Field.RTR, BitValue.DOMINANT)
        ide = CANBit(Field.IDE, BitValue.DOMINANT)
        r0b = CANBit(Field.R0, r0)
        dlc = [CANBit(Field.DLC, b) for b in int_to_bits(len(data), 4)]
        data_bits = [CANBit(Field.DATA, b) for b in bytes_to_bits(data)]
        crc = [CANBit(Field.CRC, BitValue.RECESSIVE) for _ in range(15)]
        crc_delim = CANBit(Field.CRC_DELIM, BitValue.RECESSIVE)
        ack = CANBit(Field.ACK, BitValue.RECESSIVE)
        ack_delim = CANBit(Field.ACK_DELIM, BitValue.RECESSIVE)
        eof = [CANBit(Field.EOF, BitValue.RECESSIVE) for _ in range(7)]
        return CANFrameBits(
            sof=sof, arbitration_id=arbitration_id, rtr=rtr, ide=ide, r0=r0b,
            dlc=dlc, data=data_bits, crc=crc,
            crc_delim=crc_delim, ack=ack, ack_delim=ack_delim, eof=eof
        )

    def _handle_collision(self, contenders: List[Tuple[float, object, int, bytes, BitValue]]):
        # Build bit streams for each contender
        streams = []
        for (_, ecu, arb_id, data, r0) in contenders:
            fb = self._build_frame_bits(arb_id, data, r0)
            streams.append((ecu, arb_id, data, fb.to_stream()))

        # Identify winner via bitwise arbitration:
        # At the first differing arbitration bit (SOF+ID+RTR+IDE+R0+...),
        # DOMINANT wins over RECESSIVE.
        # We simulate mismatch detection (bit monitoring) for the losing sender(s).
        max_len = max(len(s[3]) for s in streams)
        winner = streams[0]
        losers = []

        for bit_i in range(max_len):
            # Evaluate bus bit among contenders still "in arbitration"
            active = []
            for s in streams:
                if bit_i < len(s[3]):
                    active.append(s)

            if not active:
                break

            bus_bit = BitValue.RECESSIVE
            for (_, _, _, bits) in active:
                if bits[bit_i].value == BitValue.DOMINANT:
                    bus_bit = BitValue.DOMINANT
                    break

            # Determine which contenders disagree and detect monitoring error
            disagree = []
            for s in active:
                ecu, arb_id, data, bits = s
                if bits[bit_i].value != bus_bit:
                    disagree.append(s)

            if disagree:
                # The winner is any ECU driving the bus bit (i.e., matches bus_bit)
                winners = [s for s in active if s not in disagree]
                if winners:
                    winner = winners[0]
                losers = disagree
                # Error flags / counters
                for (off_ecu, _, _, _) in losers:
                    # Losing ECU detects error (bit monitoring)
                    if getattr(off_ecu, "state", NodeState.ERROR_ACTIVE) == NodeState.ERROR_ACTIVE:
                        self._send_error_flag(off_ecu, active=True)
                        off_ecu.tec += 8
                    else:
                        self._send_error_flag(off_ecu, active=False)
                        off_ecu.tec += 8  # ECU passive segnala recessive; contatore cresce comunque
                    off_ecu._update_state() if hasattr(off_ecu, "_update_state") else None

                # For the winner: if an error was signaled ACTIVE by someone, frame is aborted.
                # If only PASSIVE errors happened, the frame can continue.
                any_active_flag = any(
                    getattr(l[0], "state", NodeState.ERROR_ACTIVE) == NodeState.ERROR_ACTIVE
                    for l in losers
                )
                if any_active_flag:
                    return  # aborted

                # Passive error flags don't abort -> transmit winner frame
                w_ecu, w_id, w_data, _ = winner
                self._transmit_frame(w_ecu, w_id, w_data)
                return

        # No collision -> transmit winner by arb_id min (standard)
        streams_sorted = sorted(streams, key=lambda x: x[1])
        w_ecu, w_id, w_data, _ = streams_sorted[0]
        self._transmit_frame(w_ecu, w_id, w_data)

    def _transmit_frame(self, ecu, arb_id: int, data: bytes):
        # Successful TX: decrement TEC for the transmitter if >0
        if hasattr(ecu, "tec") and ecu.tec > 0:
            ecu.tec -= 1
            if hasattr(ecu, "_update_state"):
                ecu._update_state()

        self._send_on_vcan(arb_id, data)

    def _run(self):
        while self.running:
            time.sleep(0.005)
            with self.lock:
                if not self.pending:
                    continue

                # collect all contenders currently pending
                contenders = self.pending
                self.pending = []

            if len(contenders) == 1:
                _, ecu, arb_id, data, _r0 = contenders[0]
                self._transmit_frame(ecu, arb_id, data)
            else:
                self._handle_collision(contenders)


# --- Base ECU ---
class BaseECU:
    def __init__(self, name, slave_id, arb_id, master: CANBusMaster, tx_period=2.0, start_delay=0.0):
        self.name = name
        self.slave_id = slave_id
        self.arb_id = arb_id
        self.master = master

        self.tx_period = tx_period
        self.next_tx_time = time.time() + start_delay

        self.tec = 0
        self.rec = 0
        self.state = NodeState.ERROR_ACTIVE

        self.random_payload = False

        self.running = False
        self._thread = None

        self.master.register_ecu(self)

    def start(self):
        self.running = True
        self._thread = threading.Thread(target=self._run, daemon=True)
        self._thread.start()

    def stop(self):
        self.running = False

    def is_bus_off(self) -> bool:
        return self.state is NodeState.BUS_OFF

    def _update_state(self):
        if self.tec >= 256:
            self.state = NodeState.BUS_OFF
            print(f"[{self.name}] *** ENTERED BUS-OFF STATE *** (TEC={self.tec})")
        elif self.tec >= 128:
            if self.state != NodeState.ERROR_PASSIVE:
                self.state = NodeState.ERROR_PASSIVE
                print(f"[{self.name}] Entered ERROR-PASSIVE state (TEC={self.tec})")
        else:
            self.state = NodeState.ERROR_ACTIVE

    def _build_payload(self) -> bytes:
        if self.random_payload:
            return bytes([random.randint(0, 255) for _ in range(8)])
        return bytes([0] * 8)

    def get_time_until_tx(self) -> float:
        return max(0.0, self.next_tx_time - time.time())

    def _run(self):
        while self.running and not self.is_bus_off():
            now = time.time()
            dt = self.next_tx_time - now
            if dt <= 0:
                data = self._build_payload()
                print(f"[{self.name}] VUOLE TRASMETTERE (ID=0x{self.arb_id:03X}) TEC={self.tec} REC={self.rec} State={self.state.name}")
                self.master.submit_transmission(self, data, self.arb_id, r0=BitValue.RECESSIVE)

                # schedule senza drift (mantiene periodo costante)
                self.next_tx_time += self.tx_period
                # se eravamo in ritardo tanto, "recupera"
                while self.next_tx_time <= now:
                    self.next_tx_time += self.tx_period

                continue

            time.sleep(min(dt, 0.005))


# --- Weeping Attacker ---
class WeepingAttacker:
    def __init__(self, master: CANBusMaster, sniff_duration_1=150, sniff_duration_2=30):
        self.name = "ATTACKER"
        self.slave_id = 999
        self.master = master
        self.sniff_duration_1 = sniff_duration_1  # 75% training
        self.sniff_duration_2 = sniff_duration_2  # 25% reinforcement

        self.tec = 0
        self.rec = 0
        self.state = NodeState.ERROR_ACTIVE

        self.running = False
        self.attack_state = "sniffing_1"  # sniffing_1, analyzing, sniffing_2, reinforcement, attacking

        # Sniffing data
        self.sniffed_data_1 = defaultdict(list)
        self.sniffed_data_2 = defaultdict(list)
        self.min_sniffed_id = None

        self.seen_ids = set()
        self.reset_id = None

        # Victim
        self.victim_id = None
        self.victim_ecu = None
        self.victim_messages = []
        self.victim_bit_probabilities = []
        self.avg_interval = None
        self.last_victim_time = None
        self.next_attack_time = None

        # --- Anti flood / anti self-collision ---
        self._last_attacked_cycle_ts: Optional[float] = None
        self._pending_cycle_ts: Optional[float] = None

        # Attack params
        self.attack_r0 = BitValue.RECESSIVE         # R0=1 (recessive) per NON forzare mismatch su R0; mismatch avviene sui DATA bit scelti dal learning
        self.reset_frames_per_round = 3             # (non usato direttamente: _reduce_tec usa 1..3)

        self._thread = None
        self._vcan_listener_thread = None
        self._stop = False

        # Dedicated socketCAN listener (do NOT reuse master's socket)
        self.sniff_bus = None
        if self.master.use_vcan:
            try:
                self.sniff_bus = can.interface.Bus(channel='vcan0', interface='socketcan')
                print("[ATTACKER] Connected dedicated sniff socket to vcan0")
            except Exception as e:
                print(f"[ATTACKER] Error connecting dedicated sniff socket to vcan0: {e}")
                self.sniff_bus = None

        self.master.register_ecu(self)

    def start(self):
        self.running = True
        self._thread = threading.Thread(target=self._run, daemon=True)
        self._thread.start()

        self._vcan_listener_thread = threading.Thread(target=self._vcan_listener, daemon=True)
        self._vcan_listener_thread.start()

    def stop(self):
        self.running = False
        self._stop = True
        try:
            if self.sniff_bus is not None:
                self.sniff_bus.shutdown()
        except Exception:
            pass

    def is_bus_off(self) -> bool:
        return self.state is NodeState.BUS_OFF

    def _update_state(self):
        if self.tec >= 256:
            self.state = NodeState.BUS_OFF
            print(f"[ATTACKER] *** ENTERED BUS-OFF STATE *** (TEC={self.tec})")
        elif self.tec >= 128:
            if self.state != NodeState.ERROR_PASSIVE:
                self.state = NodeState.ERROR_PASSIVE
                print(f"[ATTACKER] Entered ERROR-PASSIVE state (TEC={self.tec})")
        else:
            self.state = NodeState.ERROR_ACTIVE

    def get_time_until_tx(self) -> float:
        # Non ha schedule fisso: attacca in finestra della vittima
        return 0.0

    def _vcan_listener(self):
        """Listener dedicato su vcan0 per sniffing indipendente."""
        if self.sniff_bus is None:
            return
        while self.running and not self._stop:
            try:
                msg = self.sniff_bus.recv(timeout=1.0)
                if msg is None:
                    continue
                arb_id = msg.arbitration_id
                data = bytes(msg.data)

                # Registra a seconda della fase
                ts = time.time()
                if self.attack_state == "sniffing_1":
                    self.sniffed_data_1[arb_id].append((ts, data))
                    self.seen_ids.add(arb_id)
                elif self.attack_state == "sniffing_2":
                    self.sniffed_data_2[arb_id].append((ts, data))
                    self.seen_ids.add(arb_id)

                # Memorizza ultimo timestamp della vittima (per schedule attacco)
                if self.victim_id is not None and arb_id == self.victim_id:
                    self.last_victim_time = ts

            except Exception:
                continue

    def _run(self):
        # Phase 1: Sniffing 1
        print(f"\n{'='*100}")
        print(f"[ATTACKER] PHASE 1: SNIFFING (Training) for {self.sniff_duration_1} seconds...")
        print(f"{'='*100}\n")

        self.attack_state = "sniffing_1"
        sniff_start_1 = time.time()
        while time.time() - sniff_start_1 < self.sniff_duration_1:
            time.sleep(2)
            print(f"[ATTACKER] Collected {sum(len(v) for v in self.sniffed_data_1.values())} total messages in training")

        # Phase 2: Analyze + select victim
        print(f"\n{'='*100}")
        print(f"[ATTACKER] PHASE 2: ANALYZING captured traffic...")
        print(f"{'='*100}\n")

        self.attack_state = "analyzing"
        self._select_victim()
        if self.victim_id is None:
            return
        self._analyze_victim_bits()

        # Phase 3: Sniffing 2 (Reinforcement)
        print(f"\n{'='*100}")
        print(f"[ATTACKER] PHASE 3: SNIFFING (Reinforcement) for {self.sniff_duration_2} seconds...")
        print(f"{'='*100}\n")

        self.attack_state = "sniffing_2"
        sniff_start_2 = time.time()
        while time.time() - sniff_start_2 < self.sniff_duration_2:
            time.sleep(2)
            if self.victim_id in self.sniffed_data_2:
                print(f"[ATTACKER] Collected {len(self.sniffed_data_2[self.victim_id])} reinforcement messages")

        # Phase 4: Reinforcement Learning
        print(f"\n{'='*100}")
        print(f"[ATTACKER] PHASE 4: REINFORCEMENT LEARNING...")
        print(f"{'='*100}\n")

        self.attack_state = "reinforcement"
        self._reinforcement_learning()

        # Phase 5: Attack
        print(f"\n{'='*100}")
        print(f"[ATTACKER] üéØ ATTACCO INIZIATO! üéØ")
        print(f"[ATTACKER] Target: ID=0x{self.victim_id:03X}")
        print(f"[ATTACKER] Strategy: send SAME ID and flip one DATA bit (0‚Üí1) where P(victim bit=0) is maximum (learning-based)")
        print(f"{'='*100}\n")

        self.attack_state = "attacking"
        self._attack_loop()

    def _robust_interval_estimate(self, times: List[float]) -> Optional[float]:
        if len(times) < 3:
            return None
        intervals = [t2 - t1 for t1, t2 in zip(times[:-1], times[1:])]
        intervals = [x for x in intervals if x > 0.0005]
        if not intervals:
            return None
        med = float(np.median(intervals))
        kept = [x for x in intervals if 0.5 * med <= x <= 1.5 * med]
        if len(kept) >= 2:
            return float(np.mean(kept))
        return med

    def _select_victim(self):
        """Seleziona la vittima (ID che trasmette pi√π frequentemente)."""
        if not self.sniffed_data_1:
            print("[ATTACKER] ‚ùå No data sniffed during phase 1")
            return

        self.victim_id = max(self.sniffed_data_1, key=lambda k: len(self.sniffed_data_1[k]))
        self.victim_messages = self.sniffed_data_1[self.victim_id]

        # Trova riferimento all'ECU reale
        self.victim_ecu = None
        for ecu in self.master.ecus.values():
            if getattr(ecu, 'arb_id', None) == self.victim_id and getattr(ecu, 'name', '') != self.name:
                self.victim_ecu = ecu
                break

        print(f"[ATTACKER] ‚úì Selected victim: ID=0x{self.victim_id:03X}")
        print(f"[ATTACKER]   Training messages captured: {len(self.victim_messages)}")
        if self.victim_ecu:
            print(f"[ATTACKER]   Victim ECU object: {self.victim_ecu.name}")

        # Calcola avg_interval su training
        times = [t for (t, _) in self.victim_messages]
        self.avg_interval = self._robust_interval_estimate(times)
        if self.avg_interval:
            print(f"[ATTACKER] ‚úì Estimated victim interval: ~{self.avg_interval:.3f}s")
        else:
            print("[ATTACKER] ‚ö†Ô∏è Could not estimate victim interval robustly")

    def _analyze_victim_bits(self):
        """Calcola la probabilit√† bit-level (0/1) sul payload della vittima."""
        if not self.victim_messages:
            return

        bit_counts = [{"0": 0, "1": 0} for _ in range(64)]
        for (_, data) in self.victim_messages:
            bits = bytes_to_bits(data)
            for i, b in enumerate(bits[:64]):
                if b == BitValue.DOMINANT:
                    bit_counts[i]["0"] += 1
                else:
                    bit_counts[i]["1"] += 1

        self.victim_bit_probabilities = []
        total = len(self.victim_messages)
        for i, bc in enumerate(bit_counts):
            p0 = bc["0"] / total if total > 0 else 0.5
            p1 = bc["1"] / total if total > 0 else 0.5
            self.victim_bit_probabilities.append({
                "position": i,
                "prob_0": p0,
                "prob_1": p1,
                "weight": 1.0
            })

        print("[ATTACKER] ‚úì Computed victim bit probabilities (first 16 bits):")
        for d in self.victim_bit_probabilities[:16]:
            print(f"  bit {d['position']:2d} -> P0={d['prob_0']:.2f}, P1={d['prob_1']:.2f}")

    def _reinforcement_learning(self):
        """Aggiusta i pesi in base a quanto la predizione MAP √® corretta su sniffed_data_2."""
        if self.victim_id is None:
            return
        msgs = self.sniffed_data_2.get(self.victim_id, [])
        if not msgs:
            print("[ATTACKER] ‚ö†Ô∏è No reinforcement messages collected")
            return

        # Predizione MAP dal training
        pred = [0 if d["prob_0"] >= d["prob_1"] else 1 for d in self.victim_bit_probabilities]

        # update weights
        for (_, data) in msgs:
            bits = bytes_to_bits(data)
            for i in range(64):
                actual = 0 if bits[i] == BitValue.DOMINANT else 1
                if actual == pred[i]:
                    self.victim_bit_probabilities[i]["weight"] *= 1.05
                else:
                    self.victim_bit_probabilities[i]["weight"] *= 0.95

        # clamp weights
        for i in range(64):
            w = self.victim_bit_probabilities[i]["weight"]
            self.victim_bit_probabilities[i]["weight"] = max(0.1, min(10.0, w))

        print("[ATTACKER] ‚úì Reinforcement updated weights (first 16 bits):")
        for d in self.victim_bit_probabilities[:16]:
            print(f"  bit {d['position']:2d} -> weight={d['weight']:.2f}")

    def _wait_for_victim_transmission(self):
        """Sincronizza l'attacco con il periodo stimato della vittima."""
        if self.avg_interval is None:
            time.sleep(0.2)
            return

        # se ho timestamp ultimo frame vittima, attendo circa avg_interval
        now = time.time()
        if self.last_victim_time is None:
            time.sleep(0.2)
            return

        # Evita multi-submit nello stesso ciclo
        if self._last_attacked_cycle_ts is not None and abs(self.last_victim_time - self._last_attacked_cycle_ts) < 1e-3:
            time.sleep(0.05)
            return

        next_time = self.last_victim_time + self.avg_interval
        self._pending_cycle_ts = self.last_victim_time

        while self.running and time.time() < next_time:
            time.sleep(0.001)

    def _reduce_tec(self):
        """Invia 1..3 frame random con ID alto per abbassare TEC senza disturbare la prossima TX della vittima."""
        rounds = random.randint(1, 3)
        for _ in range(rounds):
            if not self.running:
                break
            rid = 0x700
            payload = bytes([random.randint(0, 255) for _ in range(8)])
            self.master.submit_transmission(self, payload, rid, r0=BitValue.RECESSIVE)
            time.sleep(0.01)

    def _create_attack_message(self) -> bytes:
        """Crea il payload dell'attacco (campo DATA, 8 byte) usando le probabilit√† stimate.

        Strategia (lightweight learning):
        - Da victim_bit_probabilities (posizione 0..63, prob_0/prob_1, opzionale 'weight') costruiamo un payload
          "predetto" bit-a-bit (MAP): bit=0 se prob_0>=prob_1 altrimenti 1.
        - Scegliamo poi UN solo bit target dove la vittima ha massima probabilit√† di inviare 0
          (massimizza prob_0 * weight, se 'weight' esiste; altrimenti solo prob_0).
        - Flippiamo quel bit a 1 (0‚Üí1) cos√¨ l'attaccante differisce dalla vittima solo in quel punto.
        """
        # Default: se non ho info, payload aggressivo (tutto 0)
        probs0 = [0.5] * 64
        probs1 = [0.5] * 64
        weights = [1.0] * 64

        if self.victim_bit_probabilities:
            for d in self.victim_bit_probabilities:
                try:
                    pos = int(d.get('position', 0))
                except Exception:
                    continue
                if 0 <= pos < 64:
                    p0 = float(d.get('prob_0', 0.5))
                    p1 = float(d.get('prob_1', 0.5))
                    s = p0 + p1
                    if s > 0:
                        p0, p1 = p0 / s, p1 / s
                    probs0[pos] = max(0.0, min(1.0, p0))
                    probs1[pos] = max(0.0, min(1.0, p1))
                    w = d.get('weight', 1.0)
                    try:
                        weights[pos] = max(0.01, float(w))
                    except Exception:
                        weights[pos] = 1.0

        # 1) Predizione MAP del payload vittima (pos 0 √® MSB del byte 0)
        predicted_bits = [0 if probs0[i] >= probs1[i] else 1 for i in range(64)]

        # 2) Selezione bit target: max P0 * weight, ma solo se il payload predetto ha 0 in quel bit
        best_pos = None
        best_score = -1.0
        for i in range(64):
            if predicted_bits[i] == 0:
                score = probs0[i] * weights[i]
                if score > best_score:
                    best_score = score
                    best_pos = i

        # 3) Flippa il bit target 0‚Üí1
        if best_pos is not None:
            predicted_bits[best_pos] = 1
            byte_idx = best_pos // 8
            bit_idx = 7 - (best_pos % 8)
            conf0 = probs0[best_pos] * 100.0
            print(f"[ATTACKER] üéØ Target DATA bit {best_pos} (Byte {byte_idx}, Bit {bit_idx}): "
                  f"P0‚âà{conf0:.1f}% | score={best_score:.3f} -> flip to 1")
        else:
            print("[ATTACKER] (warn) Nessun bit predetto a 0: uso payload tutto 0.")

        # 4) Pack bits -> 8 bytes (MSB-first)
        payload = bytearray(8)
        for pos in range(64):
            if predicted_bits[pos]:
                b = pos // 8
                k = 7 - (pos % 8)
                payload[b] |= (1 << k)

        return bytes(payload)

    def _attack_loop(self):
        """Loop principale dell'attacco: collide ad OGNI tentativo della vittima."""
        attack_count = 0

        while self.running and not self.is_bus_off():
            if self.victim_ecu is not None and self.victim_ecu.is_bus_off():
                return

            # Aspetta finestra della vittima
            self._wait_for_victim_transmission()
            if not self.running:
                break

            # marca il ciclo (per evitare multi-submit prima che la vittima aggiorni next_tx_time)
            if self._pending_cycle_ts is not None:
                self._last_attacked_cycle_ts = self._pending_cycle_ts
                self._pending_cycle_ts = None

            attack_count += 1
            print(f"\n{'='*60}")
            print(f"[ATTACKER] üéØ ATTACK #{attack_count} on victim {hex(self.victim_id)}")
            print(f"{'='*60}")

            attack_data = self._create_attack_message()

            # Sottometti attacco: stesso ID della vittima + R0 uguale alla vittima (recessive). La collisione/mismatch √® sui DATA bit.
            self.master.submit_transmission(self, attack_data, self.victim_id, r0=self.attack_r0)

            # Dai tempo al master di processare collisione
            time.sleep(0.05)

            # Abbassa TEC dell'attacker senza disturbare la prossima TX della vittima
            if self.tec > 0:
                print(f"[ATTACKER] ‚ö†Ô∏è Reducing TEC after attack (current: {self.tec}) ...")
                self._reduce_tec()

            time.sleep(0.01)


# --- Main ---
def main():
    print("="*100)
    print("WEEPING CAN ATTACK SIMULATOR - BIT-LEVEL ANALYSIS + REINFORCEMENT LEARNING")
    print("="*100)

    master = CANBusMaster(use_vcan=True)
    master.start()

    # Create ECUs
    ecu_a = BaseECU("ECU_A", 1, 0x100, master, tx_period=5.0, start_delay=2.0)
    ecu_b = BaseECU("ECU_B", 2, 0x200, master, tx_period=6.0, start_delay=2.0)
    ecu_c = BaseECU("ECU_C", 3, 0x300, master, tx_period=9.0, start_delay=2.0)
    ecu_d = BaseECU("ECU_D", 4, 0x400, master, tx_period=14.0, start_delay=2.0)

    ecus = [ecu_a, ecu_b, ecu_c, ecu_d]
    # Payload totalmente random per ogni ECU (richiesto)
    for ecu in ecus:
        ecu.random_payload = True

    # Create attacker (150s training + 30s reinforcement)
    attacker = WeepingAttacker(master, sniff_duration_1=150, sniff_duration_2=30)

    for ecu in ecus:
        ecu.start()

    attacker.start()

    try:
        while True:
            time.sleep(1)
            if ecu_a.is_bus_off():
                print("[MAIN] Victim ECU_A is BUS-OFF. Stopping simulation.")
                break
    except KeyboardInterrupt:
        pass

    for ecu in ecus:
        ecu.stop()
    attacker.stop()
    master.stop()


if __name__ == "__main__":
    main()
